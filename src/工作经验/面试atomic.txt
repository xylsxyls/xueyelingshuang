atomic实现方式
硬件支持：在许多现代计算机体系结构中，原子操作已经由硬件直接支持。这意味着 CPU 提供了特殊的指令，如 Compare-and-Swap (CAS) 或 Load-Linked/Store-Conditional (LL/SC) 来执行原子操作。这些指令确保了多个线程同时访问共享变量时的正确性。

操作系统原语：在一些没有硬件支持的体系结构中，操作系统可以提供原子操作的实现。操作系统内核可以通过锁或其他机制来确保原子性。

锁机制：在一些情况下，编译器和标准库可以使用锁（如互斥锁）来实现 std::atomic 操作。这是一种软件级别的原子性，通常用于不支持硬件原子操作的架构。

内联汇编：一些编译器使用内联汇编来调用底层的原子操作指令，以实现 std::atomic 操作。


std::atomic 模板可以包含自定义的类，但有一些限制和要求。

默认构造函数和复制构造函数：为了使用自定义类类型作为 std::atomic 模板参数，该类必须具有默认构造函数和复制构造函数。这是因为 std::atomic 操作可能涉及到复制和交换操作。

操作符重载：如果您希望在自定义类类型上执行原子操作，您需要为该类定义适当的操作符重载，如 operator=、operator+=、operator-= 等，以便 std::atomic 可以执行这些操作。

可移动语义：如果您的自定义类包含动态分配的资源，那么还应该支持可移动语义（Move Semantics），以便在原子操作中高效地移动对象。

以下是一个示例，演示如何在自定义类上使用 std::atomic：

cpp
Copy code
#include <iostream>
#include <atomic>

class MyCounter {
public:
    MyCounter() : value(0) {}
    MyCounter(int val) : value(val) {}

    // 操作符重载
    MyCounter& operator=(const MyCounter& other) {
        value = other.value;
        return *this;
    }

    MyCounter& operator+=(const MyCounter& other) {
        value += other.value;
        return *this;
    }

    int getValue() const { return value; }

private:
    int value;
};

int main() {
    std::atomic<MyCounter> counter1;
    counter1 = MyCounter(42);

    std::atomic<MyCounter> counter2(MyCounter(10));

    counter1 += MyCounter(5);

    std::cout << "Counter 1: " << counter1.load().getValue() << std::endl;
    std::cout << "Counter 2: " << counter2.load().getValue() << std::endl;

    return 0;
}
在这个示例中，我们定义了一个 MyCounter 类，并为其提供了适当的操作符重载，以便在 std::atomic 中使用。然后，我们创建了两个 std::atomic 变量，分别执行了一些原子操作。请注意，我们使用 load() 方法来获取 std::atomic 变量的值以进行输出。