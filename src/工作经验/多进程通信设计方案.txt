先把所有可以使用的共享内存号放到申请空间里
共享内存号，抢占点，抢占进程号
如果不是0，则后4字节+1，得到1的返回的拿走空闲号
然后进行存储
存储后到读取共享内存中，加上第一个4字节的值再先找前4字节是0的，如果是0则在后4字节+1，得到1返回的写入已写好的共享内存号，否则到下一个后4字节中尝试拿1，超过循环后置为0
写完后通知

读取进程扫描读取共享内存，第二个4字节记录读取位置
先加上第二个4字节，拿到一个共享内存号后，先将前后两个4字节置为0，先置前再置后，再把第二个4字节+1，如果等于最大缓冲区个数则置为0，再进行拷贝，在拷贝任务中拷贝结束后把该共享内存号置为可用状态
如果读到第一个4字节为0，第二个4字节不为0，需要判断是否是发送进程在抢占之后崩溃了
需要设置一个变量overCount，每多读取一个就++，每遇到一个异常情况就--，如果在overCount为0的时候遇到异常情况则说明发送进程崩溃了，需要把第二个4字节+1，并把占点重置为0，因为overCount和processWait个数相对应，所以不需要做++

新开扫描坏区线程
每隔一秒扫描共享内存队列，如果有抢占点，有抢占进程号，则看进程号在不在，不在则去掉抢占点，如果进程号为0，则等待100毫秒，再看进程号数值，如果仍然为0，则把抢占点加上缓冲区数量，并再等100毫秒，如果抢占点数量和进程号仍然不变则都重置为0
为了防止抢占之后进程崩溃，和两次100毫秒的点都是两次的正常抢占

去掉进程号

20 1 46 2 48 2