// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoMessage.proto

#ifndef PROTOBUF_ProtoMessage_2eproto__INCLUDED
#define PROTOBUF_ProtoMessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace pt {
class KeyListData;
class KeyListDataDefaultTypeInternal;
extern KeyListDataDefaultTypeInternal _KeyListData_default_instance_;
class KeyMapData;
class KeyMapDataDefaultTypeInternal;
extern KeyMapDataDefaultTypeInternal _KeyMapData_default_instance_;
class KeyTableData;
class KeyTableDataDefaultTypeInternal;
extern KeyTableDataDefaultTypeInternal _KeyTableData_default_instance_;
class ListData;
class ListDataDefaultTypeInternal;
extern ListDataDefaultTypeInternal _ListData_default_instance_;
class MapData;
class MapDataDefaultTypeInternal;
extern MapDataDefaultTypeInternal _MapData_default_instance_;
class ProtoMessage;
class ProtoMessageDefaultTypeInternal;
extern ProtoMessageDefaultTypeInternal _ProtoMessage_default_instance_;
class RspCode;
class RspCodeDefaultTypeInternal;
extern RspCodeDefaultTypeInternal _RspCode_default_instance_;
class TableData;
class TableDataDefaultTypeInternal;
extern TableDataDefaultTypeInternal _TableData_default_instance_;
}  // namespace pt

namespace pt {

namespace protobuf_ProtoMessage_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_ProtoMessage_2eproto

// ===================================================================

class RspCode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pt.RspCode) */ {
 public:
  RspCode();
  virtual ~RspCode();

  RspCode(const RspCode& from);

  inline RspCode& operator=(const RspCode& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RspCode& default_instance();

  static inline const RspCode* internal_default_instance() {
    return reinterpret_cast<const RspCode*>(
               &_RspCode_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(RspCode* other);

  // implements Message ----------------------------------------------

  inline RspCode* New() const PROTOBUF_FINAL { return New(NULL); }

  RspCode* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RspCode& from);
  void MergeFrom(const RspCode& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RspCode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string errorMessage = 2;
  void clear_errormessage();
  static const int kErrorMessageFieldNumber = 2;
  const ::std::string& errormessage() const;
  void set_errormessage(const ::std::string& value);
  #if LANG_CXX11
  void set_errormessage(::std::string&& value);
  #endif
  void set_errormessage(const char* value);
  void set_errormessage(const char* value, size_t size);
  ::std::string* mutable_errormessage();
  ::std::string* release_errormessage();
  void set_allocated_errormessage(::std::string* errormessage);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pt.RspCode)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr errormessage_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct protobuf_ProtoMessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MapData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pt.MapData) */ {
 public:
  MapData();
  virtual ~MapData();

  MapData(const MapData& from);

  inline MapData& operator=(const MapData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapData& default_instance();

  static inline const MapData* internal_default_instance() {
    return reinterpret_cast<const MapData*>(
               &_MapData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(MapData* other);

  // implements Message ----------------------------------------------

  inline MapData* New() const PROTOBUF_FINAL { return New(NULL); }

  MapData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MapData& from);
  void MergeFrom(const MapData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MapData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:pt.MapData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable int _cached_size_;
  friend struct protobuf_ProtoMessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pt.ListData) */ {
 public:
  ListData();
  virtual ~ListData();

  ListData(const ListData& from);

  inline ListData& operator=(const ListData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListData& default_instance();

  static inline const ListData* internal_default_instance() {
    return reinterpret_cast<const ListData*>(
               &_ListData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(ListData* other);

  // implements Message ----------------------------------------------

  inline ListData* New() const PROTOBUF_FINAL { return New(NULL); }

  ListData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ListData& from);
  void MergeFrom(const ListData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ListData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:pt.ListData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable int _cached_size_;
  friend struct protobuf_ProtoMessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TableData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pt.TableData) */ {
 public:
  TableData();
  virtual ~TableData();

  TableData(const TableData& from);

  inline TableData& operator=(const TableData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TableData& default_instance();

  static inline const TableData* internal_default_instance() {
    return reinterpret_cast<const TableData*>(
               &_TableData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(TableData* other);

  // implements Message ----------------------------------------------

  inline TableData* New() const PROTOBUF_FINAL { return New(NULL); }

  TableData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TableData& from);
  void MergeFrom(const TableData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TableData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pt.ListData listData = 1;
  int listdata_size() const;
  void clear_listdata();
  static const int kListDataFieldNumber = 1;
  const ::pt::ListData& listdata(int index) const;
  ::pt::ListData* mutable_listdata(int index);
  ::pt::ListData* add_listdata();
  ::google::protobuf::RepeatedPtrField< ::pt::ListData >*
      mutable_listdata();
  const ::google::protobuf::RepeatedPtrField< ::pt::ListData >&
      listdata() const;

  // @@protoc_insertion_point(class_scope:pt.TableData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::pt::ListData > listdata_;
  mutable int _cached_size_;
  friend struct protobuf_ProtoMessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeyMapData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pt.KeyMapData) */ {
 public:
  KeyMapData();
  virtual ~KeyMapData();

  KeyMapData(const KeyMapData& from);

  inline KeyMapData& operator=(const KeyMapData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyMapData& default_instance();

  static inline const KeyMapData* internal_default_instance() {
    return reinterpret_cast<const KeyMapData*>(
               &_KeyMapData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(KeyMapData* other);

  // implements Message ----------------------------------------------

  inline KeyMapData* New() const PROTOBUF_FINAL { return New(NULL); }

  KeyMapData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KeyMapData& from);
  void MergeFrom(const KeyMapData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KeyMapData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .pt.MapData mapData = 2;
  bool has_mapdata() const;
  void clear_mapdata();
  static const int kMapDataFieldNumber = 2;
  const ::pt::MapData& mapdata() const;
  ::pt::MapData* mutable_mapdata();
  ::pt::MapData* release_mapdata();
  void set_allocated_mapdata(::pt::MapData* mapdata);

  // @@protoc_insertion_point(class_scope:pt.KeyMapData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::pt::MapData* mapdata_;
  mutable int _cached_size_;
  friend struct protobuf_ProtoMessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeyListData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pt.KeyListData) */ {
 public:
  KeyListData();
  virtual ~KeyListData();

  KeyListData(const KeyListData& from);

  inline KeyListData& operator=(const KeyListData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyListData& default_instance();

  static inline const KeyListData* internal_default_instance() {
    return reinterpret_cast<const KeyListData*>(
               &_KeyListData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(KeyListData* other);

  // implements Message ----------------------------------------------

  inline KeyListData* New() const PROTOBUF_FINAL { return New(NULL); }

  KeyListData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KeyListData& from);
  void MergeFrom(const KeyListData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KeyListData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .pt.ListData listData = 2;
  bool has_listdata() const;
  void clear_listdata();
  static const int kListDataFieldNumber = 2;
  const ::pt::ListData& listdata() const;
  ::pt::ListData* mutable_listdata();
  ::pt::ListData* release_listdata();
  void set_allocated_listdata(::pt::ListData* listdata);

  // @@protoc_insertion_point(class_scope:pt.KeyListData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::pt::ListData* listdata_;
  mutable int _cached_size_;
  friend struct protobuf_ProtoMessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeyTableData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pt.KeyTableData) */ {
 public:
  KeyTableData();
  virtual ~KeyTableData();

  KeyTableData(const KeyTableData& from);

  inline KeyTableData& operator=(const KeyTableData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyTableData& default_instance();

  static inline const KeyTableData* internal_default_instance() {
    return reinterpret_cast<const KeyTableData*>(
               &_KeyTableData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(KeyTableData* other);

  // implements Message ----------------------------------------------

  inline KeyTableData* New() const PROTOBUF_FINAL { return New(NULL); }

  KeyTableData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KeyTableData& from);
  void MergeFrom(const KeyTableData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KeyTableData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .pt.TableData tableData = 2;
  bool has_tabledata() const;
  void clear_tabledata();
  static const int kTableDataFieldNumber = 2;
  const ::pt::TableData& tabledata() const;
  ::pt::TableData* mutable_tabledata();
  ::pt::TableData* release_tabledata();
  void set_allocated_tabledata(::pt::TableData* tabledata);

  // @@protoc_insertion_point(class_scope:pt.KeyTableData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::pt::TableData* tabledata_;
  mutable int _cached_size_;
  friend struct protobuf_ProtoMessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtoMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pt.ProtoMessage) */ {
 public:
  ProtoMessage();
  virtual ~ProtoMessage();

  ProtoMessage(const ProtoMessage& from);

  inline ProtoMessage& operator=(const ProtoMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoMessage& default_instance();

  static inline const ProtoMessage* internal_default_instance() {
    return reinterpret_cast<const ProtoMessage*>(
               &_ProtoMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(ProtoMessage* other);

  // implements Message ----------------------------------------------

  inline ProtoMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtoMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProtoMessage& from);
  void MergeFrom(const ProtoMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProtoMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pt.RspCode rspCode = 1;
  bool has_rspcode() const;
  void clear_rspcode();
  static const int kRspCodeFieldNumber = 1;
  const ::pt::RspCode& rspcode() const;
  ::pt::RspCode* mutable_rspcode();
  ::pt::RspCode* release_rspcode();
  void set_allocated_rspcode(::pt::RspCode* rspcode);

  // .pt.KeyMapData keyMapData = 2;
  bool has_keymapdata() const;
  void clear_keymapdata();
  static const int kKeyMapDataFieldNumber = 2;
  const ::pt::KeyMapData& keymapdata() const;
  ::pt::KeyMapData* mutable_keymapdata();
  ::pt::KeyMapData* release_keymapdata();
  void set_allocated_keymapdata(::pt::KeyMapData* keymapdata);

  // .pt.KeyListData keyListData = 3;
  bool has_keylistdata() const;
  void clear_keylistdata();
  static const int kKeyListDataFieldNumber = 3;
  const ::pt::KeyListData& keylistdata() const;
  ::pt::KeyListData* mutable_keylistdata();
  ::pt::KeyListData* release_keylistdata();
  void set_allocated_keylistdata(::pt::KeyListData* keylistdata);

  // .pt.KeyTableData keyTableData = 4;
  bool has_keytabledata() const;
  void clear_keytabledata();
  static const int kKeyTableDataFieldNumber = 4;
  const ::pt::KeyTableData& keytabledata() const;
  ::pt::KeyTableData* mutable_keytabledata();
  ::pt::KeyTableData* release_keytabledata();
  void set_allocated_keytabledata(::pt::KeyTableData* keytabledata);

  // @@protoc_insertion_point(class_scope:pt.ProtoMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pt::RspCode* rspcode_;
  ::pt::KeyMapData* keymapdata_;
  ::pt::KeyListData* keylistdata_;
  ::pt::KeyTableData* keytabledata_;
  mutable int _cached_size_;
  friend struct protobuf_ProtoMessage_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// RspCode

// int32 code = 1;
inline void RspCode::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 RspCode::code() const {
  // @@protoc_insertion_point(field_get:pt.RspCode.code)
  return code_;
}
inline void RspCode::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:pt.RspCode.code)
}

// string errorMessage = 2;
inline void RspCode::clear_errormessage() {
  errormessage_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RspCode::errormessage() const {
  // @@protoc_insertion_point(field_get:pt.RspCode.errorMessage)
  return errormessage_.GetNoArena();
}
inline void RspCode::set_errormessage(const ::std::string& value) {
  
  errormessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pt.RspCode.errorMessage)
}
#if LANG_CXX11
inline void RspCode::set_errormessage(::std::string&& value) {
  
  errormessage_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pt.RspCode.errorMessage)
}
#endif
inline void RspCode::set_errormessage(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  errormessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pt.RspCode.errorMessage)
}
inline void RspCode::set_errormessage(const char* value, size_t size) {
  
  errormessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pt.RspCode.errorMessage)
}
inline ::std::string* RspCode::mutable_errormessage() {
  
  // @@protoc_insertion_point(field_mutable:pt.RspCode.errorMessage)
  return errormessage_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RspCode::release_errormessage() {
  // @@protoc_insertion_point(field_release:pt.RspCode.errorMessage)
  
  return errormessage_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RspCode::set_allocated_errormessage(::std::string* errormessage) {
  if (errormessage != NULL) {
    
  } else {
    
  }
  errormessage_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), errormessage);
  // @@protoc_insertion_point(field_set_allocated:pt.RspCode.errorMessage)
}

// -------------------------------------------------------------------

// MapData

// string key = 1;
inline void MapData::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MapData::key() const {
  // @@protoc_insertion_point(field_get:pt.MapData.key)
  return key_.GetNoArena();
}
inline void MapData::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pt.MapData.key)
}
#if LANG_CXX11
inline void MapData::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pt.MapData.key)
}
#endif
inline void MapData::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pt.MapData.key)
}
inline void MapData::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pt.MapData.key)
}
inline ::std::string* MapData::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:pt.MapData.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MapData::release_key() {
  // @@protoc_insertion_point(field_release:pt.MapData.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MapData::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:pt.MapData.key)
}

// bytes value = 2;
inline void MapData::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MapData::value() const {
  // @@protoc_insertion_point(field_get:pt.MapData.value)
  return value_.GetNoArena();
}
inline void MapData::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pt.MapData.value)
}
#if LANG_CXX11
inline void MapData::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pt.MapData.value)
}
#endif
inline void MapData::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pt.MapData.value)
}
inline void MapData::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pt.MapData.value)
}
inline ::std::string* MapData::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:pt.MapData.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MapData::release_value() {
  // @@protoc_insertion_point(field_release:pt.MapData.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MapData::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:pt.MapData.value)
}

// -------------------------------------------------------------------

// ListData

// bytes value = 1;
inline void ListData::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ListData::value() const {
  // @@protoc_insertion_point(field_get:pt.ListData.value)
  return value_.GetNoArena();
}
inline void ListData::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pt.ListData.value)
}
#if LANG_CXX11
inline void ListData::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pt.ListData.value)
}
#endif
inline void ListData::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pt.ListData.value)
}
inline void ListData::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pt.ListData.value)
}
inline ::std::string* ListData::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:pt.ListData.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListData::release_value() {
  // @@protoc_insertion_point(field_release:pt.ListData.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListData::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:pt.ListData.value)
}

// -------------------------------------------------------------------

// TableData

// repeated .pt.ListData listData = 1;
inline int TableData::listdata_size() const {
  return listdata_.size();
}
inline void TableData::clear_listdata() {
  listdata_.Clear();
}
inline const ::pt::ListData& TableData::listdata(int index) const {
  // @@protoc_insertion_point(field_get:pt.TableData.listData)
  return listdata_.Get(index);
}
inline ::pt::ListData* TableData::mutable_listdata(int index) {
  // @@protoc_insertion_point(field_mutable:pt.TableData.listData)
  return listdata_.Mutable(index);
}
inline ::pt::ListData* TableData::add_listdata() {
  // @@protoc_insertion_point(field_add:pt.TableData.listData)
  return listdata_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::pt::ListData >*
TableData::mutable_listdata() {
  // @@protoc_insertion_point(field_mutable_list:pt.TableData.listData)
  return &listdata_;
}
inline const ::google::protobuf::RepeatedPtrField< ::pt::ListData >&
TableData::listdata() const {
  // @@protoc_insertion_point(field_list:pt.TableData.listData)
  return listdata_;
}

// -------------------------------------------------------------------

// KeyMapData

// string key = 1;
inline void KeyMapData::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyMapData::key() const {
  // @@protoc_insertion_point(field_get:pt.KeyMapData.key)
  return key_.GetNoArena();
}
inline void KeyMapData::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pt.KeyMapData.key)
}
#if LANG_CXX11
inline void KeyMapData::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pt.KeyMapData.key)
}
#endif
inline void KeyMapData::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pt.KeyMapData.key)
}
inline void KeyMapData::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pt.KeyMapData.key)
}
inline ::std::string* KeyMapData::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:pt.KeyMapData.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyMapData::release_key() {
  // @@protoc_insertion_point(field_release:pt.KeyMapData.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyMapData::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:pt.KeyMapData.key)
}

// .pt.MapData mapData = 2;
inline bool KeyMapData::has_mapdata() const {
  return this != internal_default_instance() && mapdata_ != NULL;
}
inline void KeyMapData::clear_mapdata() {
  if (GetArenaNoVirtual() == NULL && mapdata_ != NULL) delete mapdata_;
  mapdata_ = NULL;
}
inline const ::pt::MapData& KeyMapData::mapdata() const {
  // @@protoc_insertion_point(field_get:pt.KeyMapData.mapData)
  return mapdata_ != NULL ? *mapdata_
                         : *::pt::MapData::internal_default_instance();
}
inline ::pt::MapData* KeyMapData::mutable_mapdata() {
  
  if (mapdata_ == NULL) {
    mapdata_ = new ::pt::MapData;
  }
  // @@protoc_insertion_point(field_mutable:pt.KeyMapData.mapData)
  return mapdata_;
}
inline ::pt::MapData* KeyMapData::release_mapdata() {
  // @@protoc_insertion_point(field_release:pt.KeyMapData.mapData)
  
  ::pt::MapData* temp = mapdata_;
  mapdata_ = NULL;
  return temp;
}
inline void KeyMapData::set_allocated_mapdata(::pt::MapData* mapdata) {
  delete mapdata_;
  mapdata_ = mapdata;
  if (mapdata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:pt.KeyMapData.mapData)
}

// -------------------------------------------------------------------

// KeyListData

// string key = 1;
inline void KeyListData::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyListData::key() const {
  // @@protoc_insertion_point(field_get:pt.KeyListData.key)
  return key_.GetNoArena();
}
inline void KeyListData::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pt.KeyListData.key)
}
#if LANG_CXX11
inline void KeyListData::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pt.KeyListData.key)
}
#endif
inline void KeyListData::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pt.KeyListData.key)
}
inline void KeyListData::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pt.KeyListData.key)
}
inline ::std::string* KeyListData::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:pt.KeyListData.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyListData::release_key() {
  // @@protoc_insertion_point(field_release:pt.KeyListData.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyListData::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:pt.KeyListData.key)
}

// .pt.ListData listData = 2;
inline bool KeyListData::has_listdata() const {
  return this != internal_default_instance() && listdata_ != NULL;
}
inline void KeyListData::clear_listdata() {
  if (GetArenaNoVirtual() == NULL && listdata_ != NULL) delete listdata_;
  listdata_ = NULL;
}
inline const ::pt::ListData& KeyListData::listdata() const {
  // @@protoc_insertion_point(field_get:pt.KeyListData.listData)
  return listdata_ != NULL ? *listdata_
                         : *::pt::ListData::internal_default_instance();
}
inline ::pt::ListData* KeyListData::mutable_listdata() {
  
  if (listdata_ == NULL) {
    listdata_ = new ::pt::ListData;
  }
  // @@protoc_insertion_point(field_mutable:pt.KeyListData.listData)
  return listdata_;
}
inline ::pt::ListData* KeyListData::release_listdata() {
  // @@protoc_insertion_point(field_release:pt.KeyListData.listData)
  
  ::pt::ListData* temp = listdata_;
  listdata_ = NULL;
  return temp;
}
inline void KeyListData::set_allocated_listdata(::pt::ListData* listdata) {
  delete listdata_;
  listdata_ = listdata;
  if (listdata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:pt.KeyListData.listData)
}

// -------------------------------------------------------------------

// KeyTableData

// string key = 1;
inline void KeyTableData::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyTableData::key() const {
  // @@protoc_insertion_point(field_get:pt.KeyTableData.key)
  return key_.GetNoArena();
}
inline void KeyTableData::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pt.KeyTableData.key)
}
#if LANG_CXX11
inline void KeyTableData::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pt.KeyTableData.key)
}
#endif
inline void KeyTableData::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pt.KeyTableData.key)
}
inline void KeyTableData::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pt.KeyTableData.key)
}
inline ::std::string* KeyTableData::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:pt.KeyTableData.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyTableData::release_key() {
  // @@protoc_insertion_point(field_release:pt.KeyTableData.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyTableData::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:pt.KeyTableData.key)
}

// .pt.TableData tableData = 2;
inline bool KeyTableData::has_tabledata() const {
  return this != internal_default_instance() && tabledata_ != NULL;
}
inline void KeyTableData::clear_tabledata() {
  if (GetArenaNoVirtual() == NULL && tabledata_ != NULL) delete tabledata_;
  tabledata_ = NULL;
}
inline const ::pt::TableData& KeyTableData::tabledata() const {
  // @@protoc_insertion_point(field_get:pt.KeyTableData.tableData)
  return tabledata_ != NULL ? *tabledata_
                         : *::pt::TableData::internal_default_instance();
}
inline ::pt::TableData* KeyTableData::mutable_tabledata() {
  
  if (tabledata_ == NULL) {
    tabledata_ = new ::pt::TableData;
  }
  // @@protoc_insertion_point(field_mutable:pt.KeyTableData.tableData)
  return tabledata_;
}
inline ::pt::TableData* KeyTableData::release_tabledata() {
  // @@protoc_insertion_point(field_release:pt.KeyTableData.tableData)
  
  ::pt::TableData* temp = tabledata_;
  tabledata_ = NULL;
  return temp;
}
inline void KeyTableData::set_allocated_tabledata(::pt::TableData* tabledata) {
  delete tabledata_;
  tabledata_ = tabledata;
  if (tabledata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:pt.KeyTableData.tableData)
}

// -------------------------------------------------------------------

// ProtoMessage

// .pt.RspCode rspCode = 1;
inline bool ProtoMessage::has_rspcode() const {
  return this != internal_default_instance() && rspcode_ != NULL;
}
inline void ProtoMessage::clear_rspcode() {
  if (GetArenaNoVirtual() == NULL && rspcode_ != NULL) delete rspcode_;
  rspcode_ = NULL;
}
inline const ::pt::RspCode& ProtoMessage::rspcode() const {
  // @@protoc_insertion_point(field_get:pt.ProtoMessage.rspCode)
  return rspcode_ != NULL ? *rspcode_
                         : *::pt::RspCode::internal_default_instance();
}
inline ::pt::RspCode* ProtoMessage::mutable_rspcode() {
  
  if (rspcode_ == NULL) {
    rspcode_ = new ::pt::RspCode;
  }
  // @@protoc_insertion_point(field_mutable:pt.ProtoMessage.rspCode)
  return rspcode_;
}
inline ::pt::RspCode* ProtoMessage::release_rspcode() {
  // @@protoc_insertion_point(field_release:pt.ProtoMessage.rspCode)
  
  ::pt::RspCode* temp = rspcode_;
  rspcode_ = NULL;
  return temp;
}
inline void ProtoMessage::set_allocated_rspcode(::pt::RspCode* rspcode) {
  delete rspcode_;
  rspcode_ = rspcode;
  if (rspcode) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:pt.ProtoMessage.rspCode)
}

// .pt.KeyMapData keyMapData = 2;
inline bool ProtoMessage::has_keymapdata() const {
  return this != internal_default_instance() && keymapdata_ != NULL;
}
inline void ProtoMessage::clear_keymapdata() {
  if (GetArenaNoVirtual() == NULL && keymapdata_ != NULL) delete keymapdata_;
  keymapdata_ = NULL;
}
inline const ::pt::KeyMapData& ProtoMessage::keymapdata() const {
  // @@protoc_insertion_point(field_get:pt.ProtoMessage.keyMapData)
  return keymapdata_ != NULL ? *keymapdata_
                         : *::pt::KeyMapData::internal_default_instance();
}
inline ::pt::KeyMapData* ProtoMessage::mutable_keymapdata() {
  
  if (keymapdata_ == NULL) {
    keymapdata_ = new ::pt::KeyMapData;
  }
  // @@protoc_insertion_point(field_mutable:pt.ProtoMessage.keyMapData)
  return keymapdata_;
}
inline ::pt::KeyMapData* ProtoMessage::release_keymapdata() {
  // @@protoc_insertion_point(field_release:pt.ProtoMessage.keyMapData)
  
  ::pt::KeyMapData* temp = keymapdata_;
  keymapdata_ = NULL;
  return temp;
}
inline void ProtoMessage::set_allocated_keymapdata(::pt::KeyMapData* keymapdata) {
  delete keymapdata_;
  keymapdata_ = keymapdata;
  if (keymapdata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:pt.ProtoMessage.keyMapData)
}

// .pt.KeyListData keyListData = 3;
inline bool ProtoMessage::has_keylistdata() const {
  return this != internal_default_instance() && keylistdata_ != NULL;
}
inline void ProtoMessage::clear_keylistdata() {
  if (GetArenaNoVirtual() == NULL && keylistdata_ != NULL) delete keylistdata_;
  keylistdata_ = NULL;
}
inline const ::pt::KeyListData& ProtoMessage::keylistdata() const {
  // @@protoc_insertion_point(field_get:pt.ProtoMessage.keyListData)
  return keylistdata_ != NULL ? *keylistdata_
                         : *::pt::KeyListData::internal_default_instance();
}
inline ::pt::KeyListData* ProtoMessage::mutable_keylistdata() {
  
  if (keylistdata_ == NULL) {
    keylistdata_ = new ::pt::KeyListData;
  }
  // @@protoc_insertion_point(field_mutable:pt.ProtoMessage.keyListData)
  return keylistdata_;
}
inline ::pt::KeyListData* ProtoMessage::release_keylistdata() {
  // @@protoc_insertion_point(field_release:pt.ProtoMessage.keyListData)
  
  ::pt::KeyListData* temp = keylistdata_;
  keylistdata_ = NULL;
  return temp;
}
inline void ProtoMessage::set_allocated_keylistdata(::pt::KeyListData* keylistdata) {
  delete keylistdata_;
  keylistdata_ = keylistdata;
  if (keylistdata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:pt.ProtoMessage.keyListData)
}

// .pt.KeyTableData keyTableData = 4;
inline bool ProtoMessage::has_keytabledata() const {
  return this != internal_default_instance() && keytabledata_ != NULL;
}
inline void ProtoMessage::clear_keytabledata() {
  if (GetArenaNoVirtual() == NULL && keytabledata_ != NULL) delete keytabledata_;
  keytabledata_ = NULL;
}
inline const ::pt::KeyTableData& ProtoMessage::keytabledata() const {
  // @@protoc_insertion_point(field_get:pt.ProtoMessage.keyTableData)
  return keytabledata_ != NULL ? *keytabledata_
                         : *::pt::KeyTableData::internal_default_instance();
}
inline ::pt::KeyTableData* ProtoMessage::mutable_keytabledata() {
  
  if (keytabledata_ == NULL) {
    keytabledata_ = new ::pt::KeyTableData;
  }
  // @@protoc_insertion_point(field_mutable:pt.ProtoMessage.keyTableData)
  return keytabledata_;
}
inline ::pt::KeyTableData* ProtoMessage::release_keytabledata() {
  // @@protoc_insertion_point(field_release:pt.ProtoMessage.keyTableData)
  
  ::pt::KeyTableData* temp = keytabledata_;
  keytabledata_ = NULL;
  return temp;
}
inline void ProtoMessage::set_allocated_keytabledata(::pt::KeyTableData* keytabledata) {
  delete keytabledata_;
  keytabledata_ = keytabledata;
  if (keytabledata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:pt.ProtoMessage.keyTableData)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace pt

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ProtoMessage_2eproto__INCLUDED
